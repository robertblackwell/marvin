<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"global.html":{"id":"global.html","title":"Global","body":" Documentation Classes ConnectionConnectionV0HttpsSlaveMastermodule.exports Global httpHttpsSlaveMitmServerpipeAndCollectStreamContentstripRequeststripResponsetestFileExists Global Members &lt;constant&gt; http This comment is more by way of a design note as at the time of writting the classes in this file are really stubs. The plan is to have a connection manager that controls a pool of sockets that are connected to remote hosts (identified by host:port) and to keep at least a selection of these open so that we dont pay the overhead of creating a new connection on every &quot;upStream&quot; request. To achieve this the ConnectionManager will be a singleton (to manage one pool of connections) and exposes only one method &quot;getConnectionForHostPort&quot;. The connection manager returns an instance of the &quot;Connection&quot; class asynchronouly to each call to&quot;getConnectionHostPort&quot; and this &quot;Connection&quot; knows how to send Http and Https rquests. Now in the real world each host:port combination also implies a protocol as the listener on that host:port knows what protocol it is able to speak. But we have to inform the connection manager (and hence the connection) what the protocol is so that it knows what type of message to send. Hence the getConnectionForHostPort takes a protocol (http or https) parameter, and connections store the protocol in an instance variable as well as the host:port Like nodejs http.request and https.request a connection is a stream and the body of a request can be piped into the connection instance HttpsSlave A backend server or slave is a normal https server that listens (is connected to via) a unix socket The main proxy server directs traffic from CONNECT requests through an/the instance of a backend server. To serve as a backend for many servernames this server must use SNI callback to get the tls.secureContext for any particular hostname/servername. The server makes use of the certstore class to manage (and if needed) create the required securecontext. options (Object) certStore : instance of CertStore listSocketPath : fullpath to a unix socket on which this server will listen MitmServer This is the main entry point to the proxy process Methods pipeAndCollectStreamContent(rStream, wStream, cb) A utility function that in one operation pipes rStream into wStream and (optionally) collects the contents of the rStream into a buffer and passes it to the cb function. If cb === null dont collect the contents Parameters: Name Type Description rStream readable stream wStream a writeable stream cb function with signture (Buffer). If null - dont collect the data stripRequest(req) Strips out properties of interest from an IncomingMessage that re[resents a http(s) request Parameters: Name Type Description req IncomingMessage Returns: literal Type Object stripResponse(resp) Strips out properties of interest from an IncomingMessage that re[resents a http(s) response Parameters: Name Type Description resp IncomingMessage Returns: literal Type Object testFileExists() Arguments options : An options object with the following properties type: currently unused dir : full path to an existing directory where a CertStore object will place two files -key.pem and -cert.pem files for each host/server it supports log : × Search results Close Documentation generated by JSDoc 3.4.2 on November 2nd 2016, 2:14:55 pm using the DocStrap template. "},"classes.list.html":{"id":"classes.list.html","title":"Classes","body":" Documentation Classes ConnectionConnectionV0HttpsSlaveMastermodule.exports Global httpHttpsSlaveMitmServerpipeAndCollectStreamContentstripRequeststripResponsetestFileExists Classes Classes Connection ConnectionV0 HttpsSlaveMaster exports × Search results Close Documentation generated by JSDoc 3.4.2 on November 2nd 2016, 2:14:55 pm using the DocStrap template. "},"index.html":{"id":"index.html","title":"Index","body":" Documentation Classes ConnectionConnectionV0HttpsSlaveMastermodule.exports Global httpHttpsSlaveMitmServerpipeAndCollectStreamContentstripRequeststripResponsetestFileExists × Search results Close Documentation generated by JSDoc 3.4.2 on November 2nd 2016, 2:14:55 pm using the DocStrap template. "},"Connection.html":{"id":"Connection.html","title":"Class: Connection","body":" Documentation Classes ConnectionConnectionV0HttpsSlaveMastermodule.exports Global httpHttpsSlaveMitmServerpipeAndCollectStreamContentstripRequeststripResponsetestFileExists Class: Connection Connection Connection manage ris like a node agent new Connection() × Search results Close Documentation generated by JSDoc 3.4.2 on November 2nd 2016, 2:14:55 pm using the DocStrap template. "},"ConnectionV0.html":{"id":"ConnectionV0.html","title":"Class: ConnectionV0","body":" Documentation Classes ConnectionConnectionV0HttpsSlaveMastermodule.exports Global httpHttpsSlaveMitmServerpipeAndCollectStreamContentstripRequeststripResponsetestFileExists Class: ConnectionV0 ConnectionV0 The V0 versions of these two classes are a simple/dumb implementation new ConnectionV0() × Search results Close Documentation generated by JSDoc 3.4.2 on November 2nd 2016, 2:14:55 pm using the DocStrap template. "},"HttpsSlaveMaster.html":{"id":"HttpsSlaveMaster.html","title":"Class: HttpsSlaveMaster","body":" Documentation Classes ConnectionConnectionV0HttpsSlaveMastermodule.exports Global httpHttpsSlaveMitmServerpipeAndCollectStreamContentstripRequeststripResponsetestFileExists Class: HttpsSlaveMaster HttpsSlaveMaster This class controls the creation and access to slave https servers. It exposes a single method getPortForHost(hostname, cb) - cb(err, port) This method will find, or create if necessary, an instance of a https server that can operate as a server for the given hostname and will return a TCP port number on which a client can connect to the designated server Two different strategies are available: non-sni (options.sni === undefined or options.sni ===false) =========================================================== This strategy creates a new slave https server for each hostname/servername and keep references to those server instances so that they can be re-used. Each server instance operates on behalf of only a signle hostname and is give a key and certificate appropriate to that hostname when it is created sni (options.sni===true) ======================== This strategy creates only a single https server instances and has it operate on behalf of multiple servernames via the SNICallback feature of https.Server. This is the preferred, and default, strategy. In both cases this class relies on an instance of the CertStore class to manage and when necessary create appropriate signed certificates. See CertStore for more info new HttpsSlaveMaster() Methods &lt;static&gt; createHttpsSlaveMaster() Factory × Search results Close Documentation generated by JSDoc 3.4.2 on November 2nd 2016, 2:14:55 pm using the DocStrap template. "},"module.html#.exports":{"id":"module.html#.exports","title":"Class: exports","body":" Documentation Classes ConnectionConnectionV0HttpsSlaveMastermodule.exports Global httpHttpsSlaveMitmServerpipeAndCollectStreamContentstripRequeststripResponsetestFileExists Class: exports exports This class implements the proxy forwarding process for http/https protocols. Takes a client req (IncomingMessage), - modifies headers as necessary, - passes it up to the target server, - gets the response from the target server - modifies that response as necessary - sends it down to the originating client - and notifies the http(s) transaction - say more about this new exports() Methods &lt;static&gt; createHttpsTunnelReport(status, host, port) Creates an object that reports a https tunnel Parameters: Name Type Description status string host string port number Returns: a report object literal &lt;static&gt; createHttpTransactionReport(protocol, req, resp) Creates an object that reports a http or proxied https request/response cycle where the request and response have been captured (not tunneled) Parameters: Name Type Description protocol string http: or https: req IncomingMessage resp IncomingMessage Returns: a report object literal forward(req, resp, cb) This method does all the heavy lifting of the proxying or request forwarding process and also provides to hook for extracting the request/response for monitoring. The procss is roughly as follows: - take the initial client request &quot;req&quot; (of type IncomingMessage) and from this construct a (maybe modified) request to the target server. This will at least involve taking the proxy stuff out of the headers. - when the response (of type IncomingMessage) arrives from the target server, from it build (fill in the details of) the response &quot;resp&quot; (of type ServerResponse )that is destined for the initial client and again there might be some header modifications. - once the response to the initial client signals &quot;finish&quot; - meaning all responsibility for this response has passed to the OS signal the outside world by triggering a &quot;finish&quot; event on the Mitm object - @TODO - this is not the correct object now so watches can log the transaction. The event name &quot;finish&quot; is probably a bit unfortunate - the finish event handler has signature function(req, res) where - req is the original client req of type IncomingMessage to which has been added a rawBody property of type Buffer - res is the response from the target server of type IncomingMessage to which (in selected cases) has been added a property rawBody. The rawBody is only added if this.shouldCollectResponseBody() returns true Parameters: Name Type Description req IncomeingMessage - the request message from the original client resp ServerResponse - the response to be sent to the initial client cb signals http(s) transaction complete - @todo - FIX shouldCollectResponseBody(res) Determine what types of response content we want to collect and signal on a finish event. The goal here is ONLY to prevent collecting into a buffer a large reponse body that we will probably never look at. For example - Probably do not want to collect image/ video/ audio/ types of content Put another way only text/ and application/ will be collected Parameters: Name Type Description res IncomingMessage × Search results Close Documentation generated by JSDoc 3.4.2 on November 2nd 2016, 2:14:55 pm using the DocStrap template. "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
