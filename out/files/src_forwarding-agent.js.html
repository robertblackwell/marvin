<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>src/forwarding-agent.js</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="icon" href="../assets/favicon.ico">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
                <h1><img src="../assets/css/logo.png" title="" width="117" height="52"></h1>
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: </em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <h2 class="off-left">APIs</h2>
                    <div id="api-tabview" class="tabview">
                        <ul class="tabs">
                            <li><a href="#api-classes">Classes</a></li>
                            <li><a href="#api-modules">Modules</a></li>
                        </ul>
                
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul id="api-classes" class="apis classes">
                                <li><a href="../classes/ForwardingAgent.html">ForwardingAgent</a></li>
                                <li><a href="../classes/HttpsSlaveMaster.html">HttpsSlaveMaster</a></li>
                                <li><a href="../classes/MitmServer.html">MitmServer</a></li>
                                <li><a href="../classes/Options_object.html">Options_object</a></li>
                                <li><a href="../classes/PerHostnameSlaveMaster.html">PerHostnameSlaveMaster</a></li>
                                <li><a href="../classes/SniSlaveMaster.html">SniSlaveMaster</a></li>
                            </ul>
                
                
                            <ul id="api-modules" class="apis modules">
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
                    Show:
                    <label for="api-show-inherited">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </div>
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<h1 class="file-heading">File: src/forwarding-agent.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
const url = require(&#x27;url&#x27;)
const http = require(&quot;http&quot;)
const https = require(&quot;https&quot;)
const _ = require(&quot;underscore&quot;)
const connectionManager = require(&quot;./connection-manager&quot;)
const LogLevels = require(&quot;./logger&quot;).LogLevels
const logger = require(&quot;./logger&quot;).createLogger(LogLevels.DEBUG)


const default_options = {
	capture :[	
		RegExp(/^text\/.*$/), 
		RegExp(/^application\/.*$/)
	],
	
}

/**
* This class implements the proxy forwarding process for http/https protocols.
* Takes a client req (IncomingMessage), 
*	-	modifies headers as necessary, 
*	-	passes it up to the target server,
* 	-	gets the response from the target server
*	-	modifies that response as necessary
*	-	sends it down to the originating client
*	-	and notifies the http(s) transaction - say more about this
* @class ForwardingAgent
*/
module.exports = class ForwardingAgent{
	/**
	* @constructor
	* @param {string} protocol - one of https: http:
	* @param {Options object} options
	*/
	constructor(protocol, options){
		this.protocol = protocol
		this.options = Object.assign(default_options, options)
		this.acceptableContent = this.options.capture;
		this.collectableContentType = [&quot;text&quot;,&quot;application&quot;]
	}
	/**
	* This method does all the heavy lifting of the proxying or request forwarding
	* process and also provides to hook for extracting the request/response for monitoring.
	*
	* The procss is roughly as follows:
	*	-	take the initial client request &quot;req&quot; (of type IncomingMessage) and from this construct a 
	*		(maybe modified) request to the target server. This will at least involve taking the proxy stuff out of
	*		the headers.
	*
	*	-	when the response (of type IncomingMessage) arrives from the target server, from it build (fill in the details of)
	*		the response &quot;resp&quot; (of type ServerResponse )that is destined for the initial client
	*		and again there might be some header modifications.
	*
	*	-	once the response to the initial client signals &quot;finish&quot; - meaning all responsibility for this response 
	*		has passed to the OS signal the outside world by triggering a &quot;finish&quot; event on the 
	*		
	*		Mitm object - @TODO - this is not the correct object now
	*
	*		so watches can log the transaction. The event name &quot;finish&quot; is probably a bit unfortunate
	*
	*	-	the finish event handler has signature function(req, res) where
	*		-	req is the original client req of type IncomingMessage to which has been added a rawBody property
	*			of type Buffer
	*		-	res is the response from the target server of type IncomingMessage to which (in selected cases) has
	*			been added a property rawBody. The rawBody is only added if this.shouldCollectResponseBody() returns true
	* @method forward
	* @param 	{Node::IncomeingMessage} req  	- 	the request message from the original client
	* @param 	{Node::ServerResponse}  resp	- 	the response to be sent to the initial client
	* @param 	{function} cb						signals http(s) transaction complete		-	@todo - FIX
	*/
	forward(req, resp, cb)
	{
		/**
		* Parse the url in prep for forwarding the request upstream
		* This stuff is still a problem 
		*/
		let pUrl = url.parse(req.url)
		let hostname = pUrl.hostname
		let port = pUrl.port
		let path = pUrl.path
		let headerHostname = req.headers[&#x27;host&#x27;]
		let headerPort = req.headers[&#x27;port&#x27;]
		let tmp = headerHostname.split(&quot;:&quot;)
		if(tmp.length == 2) {
			hostname = headerHostname = tmp[0]
			port = headerPort = tmp[1]
		}
		logger.log(&quot;ForwardingAgent::forward protocol:[%s] hostname:[%s] port:[%d] &quot;, this.protocol, hostname, port)
		logger.debug(&quot;ForwardingAgent::forward::port: &quot;, port)
				
		logger.debug(&quot;ForwardingAgent::forward::req.method&quot;, req.method)
		logger.debug(&quot;ForwardingAgent::forward::url&quot;, pUrl)
		logger.debug(&quot;ForwardingAgent::forward::hostname: &quot;, hostname)
		logger.debug(&quot;ForwardingAgent::forward::port: &quot;, port)
		logger.debug(&quot;ForwardingAgent::forward::path: &quot;, path)
		logger.debug(&quot;ForwardingAgent::forward::headerHostname: &quot;, headerHostname)
		logger.debug(&quot;ForwardingAgent::forward::headerPort: &quot;, headerPort)
		/**
		* strip out headers that should not be passed upstream and add any procy headers
		* that should be added. 
		* @TODO - research what else I have to do
		*/
		var reqHeaders = {&quot;mitm&quot;: &quot;upstream-req&quot;}; 
		Object.assign(reqHeaders, req.headers);
		var newHeaders = {&quot;mitm&quot;: &quot;upstream-req&quot;};
	
		_.each(reqHeaders, (value, key, list) =&gt;{
			// logger.info(&quot;key: &quot; + key + &quot;  value: &quot; + value + &quot; test : &quot; + ({&#x27;host&#x27;:true,&#x27;port&#x27;:true}[key]))
			if( {&#x27;host&#x27;:true,&#x27;port&#x27;:true}[key] !== true )
				newHeaders[key] = value
		})
		
		delete reqHeaders[&#x27;host&#x27;];
		delete reqHeaders[&#x27;port&#x27;];
		// logger.info([&quot;after mod headers&quot;])
		// logger.info(reqHeaders)
		// logger.info(newHeaders)
		// process.exit()
	 
	/**
	* This is a hack and needs to be fixed @FIX
	*/
		let options = {
			protocol : this.protocol,
			hostname : hostname,
			port: port,
			path : path,
			method : req.method,
			headers : reqHeaders
		}
		if( this.protocol === &quot;https:&quot;){
			options.rejectUnauthorized = false;
			// options.ca = ca @TODO
		}
		// logger.info(&quot;ForwardingAgent::forward::request options&quot;, options)
		// options = {
		// 	protocol: &quot;https:&quot;,
		// 	hostname : &quot;localhost&quot;,
		// 	port: 9443,
		// 	path : &quot;/test&quot;,
		// 	method : &quot;GET&quot;,
		// 	rejectUnauthorized: false,
		// 	headers : reqHeaders
		//
		// }
		logger.info(&quot;ForwardingAgent::forward::request options&quot;, options)
	
		/**
		* This should be easier - lets try promises so that it looks like
		*
		*	getConnection(protocol, host, port)
		*	.then(sendUpstreamRequest) 						
		*	.then(decodeUpStreamResponseAndSendToClient)	
		*	.then(notifyHttpTransactionFinished)
		*/
		const upstreamCallback = (targetServerResponse)=&gt;{
			/**
			* modify the reponse if necessary. At this time only add a mitm header to
			* so the forwarding process can be detected
			*/
			targetServerResponse.headers[&#x27;mitm&#x27;] = &quot;upstream-resp&quot;
		
			/**
			* now send the response downstream to the original client
			*/
			resp.writeHead(targetServerResponse.statusCode, targetServerResponse.headers)
			/**
			* forward the response body downstream
			* and possibly collect the response body provided the content-type is appropriate
			* do this here to ensure we dont try collecting the contents of very large
			* response bodies
			* other cleaning up of the request body and response body for display purposes
			* can take place elsewhere
			*/
			if( this.shouldCollectResponseBody(targetServerResponse) ){
				pipeAndCollectStreamContent(targetServerResponse, resp, (content)=&gt;{
					targetServerResponse.rawBody = content; // a bit of a hack - add the full captured body dynamically to the response
				})
			}else{
				targetServerResponse.pipe(resp)
				targetServerResponse.rawBody = new Buffer(&quot;&quot;)
				// pipeAndCollectStreamContent(targetServerResponse, resp, (content)=&gt;{
				// 	targetServerResponse.rawBody = new Buffer(&quot;&quot;)
				// })
			}
			resp.on(&#x27;finish&#x27;, ()=&gt;{
				/**
				* at this point the entire req/resp cycle is over so package it up 
				* and send a &quot;notification&quot; to who-ever. 
				* @NOTE - assumes &quot;this&quot; is the Mitm object
				*/
				logger.info(&quot;ForwardingAgent::finish&quot;)
				cb(this.protocol, req, targetServerResponse)
			})
		}
		if( pUrl.port) options.port = pUrl.port;
		/**
		* get a connection and when we have it send the request upstream
		*/
		var conn = connectionManager.getConnectionForHostPort(&quot;http&quot;, pUrl.hostname, options.port, (err, conn)=&gt;{
			if( err ){
				throw new Error(&quot;getConnectionForHostPort failed host :&quot; + host + &quot; port: &quot; + port)
			}
			// var upStreamReq = conn.httpRequest( options, upstreamCallback )
			var upStreamReq = (this.protocol === &quot;https:&quot;) 
				? https.request( options, upstreamCallback )
				: http.request( options, upstreamCallback )
			
			upStreamReq.on(&#x27;error&#x27;, (e) =&gt; {
				/**
				* Need to do something better with this
				*/
			  logger.error(&#x60;problem with request: ${e.message}&#x60;);
			});
	
			/**
			* pipe the request body upstream to the target server
			* and also save the request body
			*/
			pipeAndCollectStreamContent(req, upStreamReq, (content)=&gt;{
				req.rawBody = content; // also a the same hack - add the raw body dynamically to the request 
				upStreamReq.end(); // not sure about this -- maybe the pipe does this for me
			})
		
		})
		// var upStreamReq = conn.sendHttpRequest( options, upstreamCallback )
		//
		// upStreamReq.on(&#x27;error&#x27;, (e) =&gt; {
		// 	/**
		// 	* Need to do something better with this
		// 	*/
		//   logger.info(&#x60;problem with request: ${e.message}&#x60;);
		// });
		//
		// /**
		// * pipe the request body upstream to the target server
		// * and also save the request body
		// */
		// pipeAndCollectStreamContent(req, upStreamReq, (content)=&gt;{
		// 	req.rawBody = content; // also a the same hack - add the raw body dynamically to the request
		// 	upStreamReq.end(); // not sure about this -- maybe the pipe does this for me
		// })
	}
	/**
	* Determine what types of response content we want to collect and signal
	* on a finish event. The goal here is ONLY to prevent collecting into a buffer a 
	* large reponse body that we will probably never look at.
	* For example - Probably do not want to collect image/ video/ audio/ types of content
	* Put another way only text/*  and application/* will be collected
	* @method shouldCollectResponseBody
	* @param {IncomingMessage} res - response from upstream server 
	*/
	shouldCollectResponseBody(res /*IncomingMessage*/)
	{
		var result = false;
		if( res.headers[&#x27;content-type&#x27;] === undefined ){
			logger.debug(&quot;ForwardingAgent::shouldCollectResponseBody there is NO content type&quot;)
			result = true;
		}else{
			var c_type = res.headers[&#x27;content-type&#x27;]
			logger.debug(&quot;ForwardingAgent::shouldCollectResponseBody content type is &quot;, res.headers[&#x27;content-type&#x27;])
			this.acceptableContent.forEach((re)=&gt;{
				// var re = new Regex(reStr)
				logger.debug(&quot;ForwardingAgent::shouldCollectResponseBody::matching loop&quot;, c_type, (c_type.match(re)!== null) )
				if( c_type.match(re) !== null ){
					result = true;
				}
			})
		}
		logger.debug(&quot;ForwardingAgent::shouldCollectResponseBody result&quot;, result)
		return result;
	}
	
}

/**
* A utility function that in one operation pipes rStream into wStream and 
* (optionally) collects the contents of the rStream into a buffer and passes it to the
* cb function.
*
* If cb === null dont collect the contents
* @function pipeAndCollectStream
* @param {ReadableStream} rStream - readable stream
* @param {WriteableStream} wStream - a writeable stream
* @param cb - function with signture (Buffer). If null - dont collect the data
*/
function pipeAndCollectStreamContent(rStream, wStream, cb)
{
	let buffers = [];
	rStream.pipe(wStream);
	if( cb ){
		rStream.on(&#x27;data&#x27;, function(chunk){
			buffers.push(chunk)
		})
		rStream.on(&#x27;end&#x27;, function(){
			const streamContent = Buffer.concat(buffers)
			cb(streamContent)
		})
	}
}
    </pre>
</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
