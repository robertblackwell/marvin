<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>src/slave-master.js</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="icon" href="../assets/favicon.ico">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
                <h1><img src="../assets/css/logo.png" title="" width="117" height="52"></h1>
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: </em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <h2 class="off-left">APIs</h2>
                    <div id="api-tabview" class="tabview">
                        <ul class="tabs">
                            <li><a href="#api-classes">Classes</a></li>
                            <li><a href="#api-modules">Modules</a></li>
                        </ul>
                
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul id="api-classes" class="apis classes">
                                <li><a href="../classes/ForwardingAgent.html">ForwardingAgent</a></li>
                                <li><a href="../classes/HttpsSlaveMaster.html">HttpsSlaveMaster</a></li>
                                <li><a href="../classes/MitmServer.html">MitmServer</a></li>
                                <li><a href="../classes/Options_object.html">Options_object</a></li>
                                <li><a href="../classes/PerHostnameSlaveMaster.html">PerHostnameSlaveMaster</a></li>
                                <li><a href="../classes/SniSlaveMaster.html">SniSlaveMaster</a></li>
                            </ul>
                
                
                            <ul id="api-modules" class="apis modules">
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
                    Show:
                    <label for="api-show-inherited">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </div>
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<h1 class="file-heading">File: src/slave-master.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
var CertStore 	= require(&quot;./cert-store&quot;)
var https 		= require(&#x27;https&#x27;)
var fs 			= require(&#x27;fs&#x27;)
var _ 			= require(&quot;underscore&quot;)
var process 	= require(&quot;process&quot;)
const LogLevels = require(&quot;./logger&quot;).LogLevels
const logger = require(&quot;./logger&quot;).createLogger(LogLevels.LOG)

const ForwardingAgent = require(&quot;../src/forwarding-agent&quot;)

function hostKey(options, hostname){
	var keyFn = options.certDir+&quot;/&quot;+hostname+&quot;-key.pem&quot;;
	return keyFn;	
}
function hostCert(options, hostname){
	var certFn = options.certDir+&quot;/&quot;+hostname+&quot;-cert.pem&quot;;
	return certFn;
}

/**
* 	This class controls the creation and access to slave https servers.
*
* 	It exposes a single method 
*
*		getPortForHost(hostname, cb) - cb(err, port)
* 
*	This method will find, or create if necessary, an instance of a https server that
* 	can operate as a server for the given hostname and will return a TCP
* 	port number on which a client can connect to the designated server
*
* 	Two different strategies are available:
*
* 	non-sni (options.sni === undefined or options.sni ===false)
*	===========================================================
*
*	This strategy creates a new slave https server for each hostname/servername
* 	and keep references to those server instances so that they can be re-used.
*	Each server instance operates on behalf of only a signle hostname and
*	is give a key and certificate appropriate to that hostname when it is created
*
*	sni (options.sni===true)
*	========================
*
*	This strategy creates only a single https server instances and has it operate on behalf 
*	of multiple servernames via the SNICallback feature of https.Server.
*	This is the preferred, and default, strategy.
*
*
*	In both cases this class relies on an instance of the CertStore class to manage and when necessary
*	create appropriate signed certificates. See CertStore for more info
* @class HttpsSlaveMaster
*/
class HttpsSlaveMaster { //base class
	
	/**
	* A factory method to construct slave servers
	* @method createHttpsSlaveMaster 
	* @static  
	*/
	static createHttpsSlaveMaster(options, completionCb){
		let m =  _createHttpsSlaveMaster(options, completionCb);
		return m;
	}
	/**
	* @constructor
	* @param {Options object} options
	* @param {function} completionCb - to be called when the forwarding agent has processed a complete request/responbse cycle
	*/
	constructor(options, completionCb){
		logger.log(&quot;HttpsSlaveMaster starting&quot;)
		this.options = {};
		_.defaults(this.options, options, {
			sni: true,
			log: console.log
		})
		this.certStore = new CertStore(options)
		this.log = this.options.log;
		// this.log = console.log;
		this.sni = (this.options.sni !== undefined &amp;&amp; this.options.sni === true)
		logger.log(&quot;HttpsSlaveMaster::constructor::sni &quot; + this.sni)
		this.servers = {};
		
		this.slave = undefined;
		
		this.pending = (this.sni)? []: {};
		
		this.serverCount = 0;
		this.completionCb = completionCb;
		logger.debug(&quot;HttpsSlaveMaster - constructor complete&quot;, this)
	}
	/**
	* Forward the clients request upstream to the originally intended server
	* @param {IncomingMessage} res
	* @param {ServerRespsonse} resp
	* @uses an instance of {ForwardingAgent} to perform this action
	*/
	forwardRequest(req, resp){
		logger.info(&quot;HttpsSlave forwarding request url:&quot;, req.url)
		logger.info(&quot;HttpsSlave forwarding request headers:&quot;,  req.headers)
		
		const fa = new ForwardingAgent(&quot;https:&quot;, this.options)
		req.headers[&#x27;slave&#x27;] = this.whoAmI
		fa.forward(req, resp, (tReq, tResp)=&gt;{
			logger.info(&quot;HttpsSlave forward callback&quot;)
			tReq.headers[&#x27;slave&#x27;] = this.whoAmI
			tResp.headers[&#x27;slave&#x27;] = this.whoAmI
			this.completionCb(tReq, tResp)
			logger.info(&quot;HttpsSlave forward callback - return&quot;)
		})
		return;
		// this.handler(req, resp)
		logger.info(&quot;HttpsSlave server got a request&quot;)
		resp.writeHead(200)
		resp.end(&quot;OK got here&quot;)						
	}
}
/**
* A HttpsSlaveMaster derived class that can operate on behalf of multiple host names. 
* @class SniSlaveMaster
*/
class SniSlaveMaster extends HttpsSlaveMaster
{
	constructor(options, handler){
		super(options, handler)
		this.whoAmI = &quot;SniSlaveMaster&quot;
	}
	/**
	* Get a port on the local system through which a suitable slave server can be
	* communicated with 
	* @method getPortForHost
	* @param {string} hostname
	* @param {function} cb - to be called when the port has been obtained 
	*/
	getPortForHost(hostname, cb)	{
		var slave;
		logger.log(&quot;SniSlaveMaster::sniGetPortForHost&quot;, hostname)
		
		if( this.slave === undefined ){ 
			this.pending.push(cb);
			if( this.pending.length != 1 ){
				logger.info(&quot;getPort already pending &quot;, this.pending.length)
				return;
			}

			var server_options = {
				SNICallback : (servername, cb)=&gt;{
					logger.info(&quot;SNICallback : &quot;, servername)
					this.certStore.getSecureContext(servername, (err, ctx)=&gt;{
						logger.info(&quot;snicallback cb&quot;,err)
						cb(err, ctx)
					})
				}
			}
			slave = https.createServer(server_options, this.forwardRequest.bind(this));
			// 	(req, resp)=&gt;{
			// 	this.log(&quot;HttpsSlave server got a request&quot;)
			// 	resp.writeHead(200)
			// 	resp.end(&quot;OK got here&quot;)
			// })
			slave.listen(0, &quot;localhost&quot;,()=&gt;{
				logger.log(&quot;SniSlaveMaster::slave.listen::cb hostname: %s port : %d&quot;, hostname, slave.address().port)
				slave.port = slave.address().port
				// Now that we have a port hook slave into this. This signals 
				// that the slave is established
				this.slave = slave
				var callbacks = this.pending;
				this.pending = [];
				logger.info(&quot;SniSlaveMaster::slave.listen::cb drain callbacks&quot;, callbacks.length)
				for(cb of callbacks ){
					cb(null, this.slave.port)
				}
			})
		}else{
			logger.log(&quot;SniSlaveMaster::getPortForHost - reusing&quot;, this.slave.port)
			cb(null, this.slave.port)
		}
	}	
	close(){
		this.slave.close()		
	}
}
/**
* A HttpsSlaveMaster derived class, instances of which can operate on behalf of a __single__ host names.
* if this type of slave is used one must be created for each distinct upstream hostname 
* @class PerHostnameSlaveMaster
*/
class PerHostnameSlaveMaster extends HttpsSlaveMaster
{
	constructor(options, handler){
		super(options, handler)		
		this.whoAmI = &quot;PerHostnameSlaveMaster&quot;
	}
	/**
	* Get a port on the local system through which a suitable slave server can be
	* communicated with 
	* @method getPortForHost
	* @param {string} hostname
	* @param {function} cb - to be called when the port has been obtained 
	*/
	getPortForHost(hostname, cb){
		logger.log(&quot;PerHostnamesSlaveMaster::getPortForHost&quot;, hostname)
		var port;
		var serverOptions;

		if( this.servers[hostname] === undefined){
			logger.log(&quot;PerHostnamesSlaveMaster::getPortForHost::Creating server for&quot;, hostname)
			if( this.pending[hostname] === undefined ){ 
				this.pending[hostname] = [cb];
			}else{
				this.pending[hostname].push(cb);
				return; 
			}
			var svr_options = {}
			
			this.certStore.loadCert(hostname, (err, ctx)=&gt;{
				logger.info(&quot;PerHostnamesSlaveMaster::getPortForHost cert: &quot;, ctx)
				var server = https.createServer(ctx, this.forwardRequest.bind(this))
					
				// 	(req, resp)=&gt;{
				// 	this.log(&quot;HttpsSlave server got a request&quot;)
				// 	resp.writeHead(200)
				// 	resp.end(&quot;OK got here&quot;)
				// 	// forward(req, resp)
				// })
				server.listen(0, &quot;localhost&quot;, ()=&gt;{
					logger.info(&quot;PerHostnamesSlaveMaster::getPortForHost server listen port : &quot;, server.address().port)
					server.port = server.address().port
					this.servers[hostname] = server;
					var callbacks = this.pending[hostname]
					this.pending[hostname] = undefined;				
					logger.info(&quot;PerHostnamesSlaveMaster::getPortForHost drain callbacks&quot;, callbacks.length)
					for(cb of callbacks){
						cb(null, server.port)
					}
				})
			})
		}else{
			port = this.servers[hostname].address().port;
			logger.log(&quot;PerHostnamesSlaveMaster::getPortForHost Reusing server for hostname: %s port: %d&quot;, hostname, port)
			cb(null, port)
		}
	}
	close(){
		for(p in this.servers ){
			p.close()
		}
		
	}
}
/**
* A factor method that creates the appropriate type of HttpsSlaveMaster
* @method _createHttpsSlaveMaster
* @static
* @param {Options object} 
* @param {function} handler - a function that will handle req/resp pairs for sending upstream
*/
function _createHttpsSlaveMaster(options, handler){
	let slave;
	if(options.sni === undefined || options.sni === false )
		slave = new PerHostnameSlaveMaster(options, handler);
	else
		slave = new SniSlaveMaster(options, handler);
	return slave;
}



class WsSlaveMaster
{
	constructor(options){
		
	}
}
class WssSlaveMaster
{
	constructor(options){
		
	}
	
}
// module.exports = HttpsSlaveMaster
/**
* Factory 
*/
module.exports = {
	create : _createHttpsSlaveMaster,
}
    </pre>
</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
